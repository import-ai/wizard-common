from enum import Enum
from functools import partial
from typing import List, Literal, Callable, TypedDict, Awaitable, Union, get_args, cast

from pydantic import BaseModel, Field


ToolName = Literal[
    "private_search",
    "web_search",
    "product_docs",
    "get_resources",
    "get_children",
    "get_parent",
    "filter_by_time",
    "filter_by_tag",
    "filter_by_keyword",
]

# Tool categories
SEARCH_TOOLS: tuple[str, ...] = ("private_search", "web_search", "search")
RESOURCE_TOOLS: tuple[str, ...] = (
    "get_resources",
    "get_children",
    "get_parent",
    "filter_by_time",
    "filter_by_tag",
    "filter_by_keyword",
    "product_docs",
)
AsyncCallable = Callable[..., Awaitable]


class Condition(BaseModel):
    namespace_id: str
    resource_ids: list[str] | None = Field(default=None)
    parent_ids: list[str] | None = Field(default=None)
    created_at: tuple[float, float] | None = Field(default=None)
    updated_at: tuple[float, float] | None = Field(default=None)

    def to_meili_where(self) -> List[str | List[str]]:
        and_clause: List[str | List[str]] = [
            'namespace_id = "{}"'.format(self.namespace_id)
        ]
        or_clause: List[str] = []
        if self.resource_ids:
            or_clause.append(
                "chunk.resource_id IN [{}]".format(
                    ", ".join('"{}"'.format(rid) for rid in self.resource_ids)
                )
            )
        if self.parent_ids:
            or_clause.append(
                "chunk.parent_id IN [{}]".format(
                    ", ".join('"{}"'.format(pid) for pid in self.parent_ids)
                )
            )
        if or_clause:
            and_clause.append(or_clause)

        if self.created_at is not None:
            and_clause.append("chunk.created_at >= {}".format(self.created_at[0]))
            and_clause.append("chunk.created_at <= {}".format(self.created_at[1]))
        if self.updated_at is not None:
            and_clause.append("chunk.updated_at >= {}".format(self.updated_at[0]))
            and_clause.append("chunk.updated_at <= {}".format(self.updated_at[1]))

        return and_clause


class ToolExecutorConfig(TypedDict):
    name: str
    schema: dict
    func: AsyncCallable


class BaseTool(BaseModel):
    name: ToolName

    def to_func(self, func: AsyncCallable, **kwargs) -> AsyncCallable:
        return partial(func, **kwargs) if kwargs else func


class PrivateSearchResourceType(str, Enum):
    RESOURCE = "resource"
    FOLDER = "folder"


class Resource(BaseModel):
    id: str
    name: str
    type: PrivateSearchResourceType
    child_ids: list[str] | None = Field(default=None, exclude=True)


class PrivateSearchTool(BaseTool):
    name: Literal["private_search"] = "private_search"
    namespace_id: str
    visible_resources: list[Resource] = Field(
        default=None,
        exclude=True,
        description="Required in `AgentRequest`, excluded in `MessageDto`.",
    )
    resources: list[Resource] = Field(default=None)
    related_resources: list[Resource] = Field(
        default=None,
        description="Related resources of user's query, this field exists only when field resources is None. "
        "Generated by `UserQueryPreprocessor`.",
    )

    def to_condition(self) -> Condition:
        if self.visible_resources is None:
            raise AssertionError(
                "`visible_resources` must be provided when export to `Condition`."
            )
        return Condition(
            namespace_id=self.namespace_id,
            resource_ids=[r.id for r in self.visible_resources],
        )

    def to_func(self, func: AsyncCallable, /, **kwargs) -> AsyncCallable:
        return super().to_func(func, **(kwargs | {"condition": self.to_condition()}))


class WebSearchTool(BaseTool):
    name: Literal["web_search"] = "web_search"


# Resource tools - call backend API to get structured data


class BaseResourceTool(BaseTool):
    """Base class for resource tools with visible_resources support.
    """

    namespace_id: str
    visible_resources: list[Resource] | None = Field(
        default=None,
        exclude=True,
        description="List of visible resources.",
    )


class GetResourcesTool(BaseResourceTool):
    """Tool to get full content of one or more resources."""

    name: Literal["get_resources"] = "get_resources"


class GetChildrenTool(BaseResourceTool):
    """Tool to get children directory tree of a parent folder."""

    name: Literal["get_children"] = "get_children"


class GetParentTool(BaseResourceTool):
    """Tool to get parent folder of a resource."""

    name: Literal["get_parent"] = "get_parent"


class FilterByTimeTool(BaseResourceTool):
    """Tool to filter resources by creation time."""

    name: Literal["filter_by_time"] = "filter_by_time"
    parent_id: str | None = Field(default=None)


class FilterByTagTool(BaseResourceTool):
    """Tool to filter resources by tag."""

    name: Literal["filter_by_tag"] = "filter_by_tag"
    parent_id: str | None = Field(default=None)


class FilterByKeywordTool(BaseResourceTool):
    """Tool to filter resources by keyword in name or content."""

    name: Literal["filter_by_keyword"] = "filter_by_keyword"


class ProductDocsTool(BaseTool):
    """Tool to get product documentation."""

    name: Literal["product_docs"] = "product_docs"


_Tool = Union[
    PrivateSearchTool,
    WebSearchTool,
    ProductDocsTool,
    GetResourcesTool,
    GetChildrenTool,
    GetParentTool,
    FilterByTimeTool,
    FilterByTagTool,
    FilterByKeywordTool,
]
ALL_TOOLS: tuple[str] = cast(tuple[str], get_args(ToolName))


class ToolDict:
    def __init__(self, tools: list[_Tool]) -> None:
        self.tools: list[_Tool] = tools

    @property
    def dict(self) -> dict[str, _Tool]:
        return {tool.name: tool for tool in self.tools}

    def __getitem__(self, item: str) -> dict:
        return self.dict[item]

    def __contains__(self, item: str) -> bool:
        return item in self.dict

    def get(self, item: str, default=None) -> _Tool | None:
        return self.dict.get(item, default)
